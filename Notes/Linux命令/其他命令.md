## 声明
转载自黑马视频中的笔记和玄魂公众号！

## 0x01 查找文件

### find
在指定目录下查找文件
任何位于参数之前的字符串都将被视为欲查找的目录名

如果使用该命令时，不设置任何参数
则find命令将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示
```
find [目录] [选项] [-print] [-exec -ok command] {} \
```

<!--more-->

|参数|含义|
|--|--|
|-print |将查找到的文件输出到标准输出|
|-exec command {} \;|将查到的文件执行command操作, {} 和 \; 之间有空格|
|-ok|在操作前要询用户|
|-name filename|查找名为filename的文件|
|-perm|按执行权限来查找|
|-user username|按文件的拥有者来查找|
|-group groupname|按组来查找|
|-mtime -n +n|按文件更改时间来查找文件，-n指n天以内，+n指n天以前|
|-atime -n +n|按文件访问时间来查|
|-ctime -n +n|按文件创建时间来查找文件，-n指n天以内，+n指n天以前|
|-nogroup|查无有效属组的文件，即文件的属组在/etc/groups中不存在|
|-nouser|查无有效属主的文件，即文件的属主在/etc/passwd中不存|
|-newer f1 !f2|查更改时间比f1新但比f2旧的文件|
|-type b/d/c/p/l/f |查找块设备(b)、目录(d)、字符设备(c)、管道(p)、符号链接(l)、普通文件(f)|
|-size n[c]|查长度为n块[或n字节]的文件|
|-depth|查找递归的目录深度|
|-fstype|查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到|
|-mount|查文件时不跨越文件系统mount点|
|-follow|如果遇到符号链接文件，就跟踪链接所指的文件|
|-cpio|对匹配的文件使用cpio命令，将他们备份到磁带设备中|
|-prune|忽略某个目录|

常用场景：
* 将目前目录及其子目录下所有延伸档名是.c的文件列出来
```
find . -name "*.c"
```
* 将目前目录其其下子目录中所有一般文件列出
```
find . -type f
```
* 将目前目录及其子目录下所有最近 20 天内更新过的文件列出
```
find . -ctime -20
```
* .查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问
```
find /var/log -type f -mtime +7 -ok rm {} ;
```
* 查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件
```
find . -type f -perm 644 -exec ls -l {} ;
```
* 为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径
```
find / -type f -size 0 -exec ls -l {} ;
```

---

## 0x02 软链接

### ln
为某一个文件在另外一个位置建立一个同步的链接

当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件 
我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接(Link)它就可以，不必重复的占用磁盘空间

上面这些话的意思就是，就像大家天天用的Windows一样 
安装游戏的时候不是都提示你是否在桌面创建快捷方式 
这个快捷方式，起始就是一个(Link)，程序的真实位置并不在桌面上 
但是你点击桌面的快捷方式就可以打开游戏

```
ln [option] [src] [dst]
```

|参数|含义|
|--|--|
|-b|删除，覆盖以前建立的链接|
|-d|允许超级用户制作目录的硬链接|
|-f |强制执行|
|-i |交互模式，文件存在则提示用户是否覆盖|
|-n|把符号链接视为一般目录|
|-s|软链接(符号链接)|
|-v|显示详细的处理过程|



常用情景：

* 比如我们自己写了一个脚本在`/home/code/scp_key.sh上`，但是我们想在`bash`中输入`scp_key`时候就执行这个脚本

```
# 我们可以把这个路径加入到`PATH`中去，或者这样
ln -s /home/code/scp_key.sh /usr/bin/scp_key
```
注意给脚本添加执行权限


我们把这个文件建立一个软连接在`/usr/bin`下面，这样我们每次在`bash`中 输入`scp_key`的时候
就可以执行那个脚本了，因为`/usr/bin`是在`PATH`中的，软链接的好处就是你如果要给`scp_key.sh`添加了一些功能
改完`scp_key.sh`之后，不用改变在`/usr/bin`的那个链接，就可以使用新功能了

但是缺点也是显而易见的，如果`/home/code/scp_key.sh`文件丢失，那么软连接也会失效

* 如果你确定了这个代码已经很完美了，不需要改了，那我们可以创建硬链接

```
ln /home/code/scp_key.sh /usr/bin/scp_key
```
源文件被删除后，并不会影响硬链接文件

如果你删除了硬链接文件，然后再重建一个一样名字的文件，这个文件还会默认变成硬链接文件，内容和你删除前保持一致


> tips：在Linux中，文件名和文件的数据时分开存储的

* 在Linux中，只有文件的`硬链接数 == 0`才会被删除

* 使用`ls -l`可以查看一个文件的硬链接的数量

* 在日常工作中，几乎不会建立文件的硬链接



---

## 0x03 打包压缩

> tips：在不同操作系统中，常用的打包压缩方式是不同的
* `windowds`常用`rar,zip,7z`
* `mac`常用`zip`
* `Linux`常用`tar.gz`


### tar

* `tar`是Linux中最常用的备份工具


```
#打包文件
tar -cvf 打包文件.tar 被打包的文件/路径

# 解压
tar -zxvf 打包文件.tar
```



|参数|含义|
|--|--|
|c|生成档案文件，创建打包文件|
|x|解开档案文件|
|v|列出归档解挡的详细过程，显示进度|
|f|指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后|


> tips：在tar命令中有一个**`-z`**可以调用工字牌，从而可以方便的实现压缩和解压缩的功能


### gzip
* `tar`与`gzip`命令结合可以使用实现文件**打包和压缩**
* `tar`只负责打包文件，但不压缩
* 用`gzip`压缩`tar`打包后的文件，其扩展名一般用`xxx.tar.gz`

```
# 压缩文件
tar -zcvf 打包文件.tar.gz 被压缩的文件/路径

# 解压缩文件
tar -zxvf 打包文件.tar.gz

# 解压缩到指定路径
tar -zxvf 打包文件.tar.gz -C 目录路径
```

|参数|含义|
|--|--|
|-c|解压缩到指定目录|



### bzip2

* `tar`与`bzip2`命令结合可以使用实现文件**打包和压缩文件**（用法和`gzip`一样）
* `tar`只负责打包文件，但不压缩
* 用`bzip2`压缩`tar`打包后的文件，其扩展名一般用`xxx.tar.bz2`
* 在`tar`命令中有一个选项**-j**可以调用`bzip2`，从而可以方便的实现压缩和解压缩的功能



```
# 压缩文件
tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径

# 解压缩文件
tar -jxvf 打包文件.tar.bz2
```

---


## 0x04 查看Linux的CPU的信息

```
cat /proc/cpuinfo
```



---



## 0x05 查看Linux的内存信息


### free

```
free

# -m    以MB为单位
# -g    以GB为单位
```



---



## 0x06 查看Linux的发行版信息



**旧Linux版本**

```
cat /etc/release
```



**新的**

```
#CentOS7
cat /etc/redhat-release

# Ubantu 16.04
car /etc/os-release
```



## 0x07 软件安装



### 通过apt安装/卸载软件

是Linux下的一款安装包管理工具

```
# 安装软件
sudo apt install 软件包
sudo apt install htop

# 卸载软件
sudo apt remove 软件名

# 更新已安装的包
sudo apt upgrade
```



---

## 0x08 配置软件源

> tips：更新服务器之后，需要一个相对比较长时间的更新过程，徐亚耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了


* 所谓镜像源，就是**所有服务器的内容是相同的(镜像)**，但是根据所在位置不同，国内服务器通常速度会更快一些！





